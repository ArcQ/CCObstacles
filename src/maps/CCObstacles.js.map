{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/CCObstacles.js","src/ObstacleList.js","src/ObstacleObj.js","src/ObstacleProperties.js","src/ObstacleType.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"CCObstacles.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var ObstacleObj = require('./ObstacleObj');\nvar ObstacleType = require('./ObstacleType');\n\nvar ccObstacles = function(){\n\tthis.typesList = new window.dLinkedList();\n};\n\n//properties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.addObstacleType = function(type,properties){\n\t//only do something is type hasn't already been added\n\tif(this.findObstacleType(type)===undefined){\n\t\t\tif((properties===undefined)||(properties ===null)){\n\t\t\t\tproperties = {};\n\t\t\t}\n\t\t\tvar obstacleType = new ObstacleType();\n\t\t\tobstacleType.type = type;\n\n\t\t\tthis.typesList.push(obstacleType);\n\t//set optional properties\n\tthis.setObstacleProperties(obstacleType,properties);\n\t}\n};\n\n//properties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.changeObstacleTypeProperties = function(type,properties){\n\n\tvar obstacleType = this.findObstacleType(type);\n\tif((properties===undefined)||(properties ===null)){\n\t\tproperties = {};\n\t}\n\t//set optional properties\n\t\tthis.setObstacleProperties(obstacleType,properties);\n};\n\n//enterObstacle takes variable arguments (1-2) of 1.type 2.optProperties\n//optProperties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.enterObstacle = function(){\n\n\tvar type = arguments[0];\n\tvar obstacleType = this.findObstacleType(type);\n\tvar obstacle = obstacleType.enterObstacle();\n\n\tif(arguments[1] !== null){\n\t\tthis.setObstacleProperties(obstacle,arguments[1]);\n\t}\n\t\n};\n\nccObstacles.prototype.update = function(dt){\n\n\tvar updateThisType = function(otNode){\n\t\totNode.obj.update(dt);\n\t\treturn true;\n\t};\n\n\tthis.typesList.applyToEveryNode(updateThisType);\n\n}\t\t\t\t\t\n\nccObstacles.prototype.setObstacleProperties = function(obstacle,optProperties){\n\tobstacle.properties.speed = ((optProperties.speed === null) ? obstacle.properties.speed: optProperties.speed);\n\tobstacle.properties.progress = ((optProperties.progress === null) ? obstacle.properties.progress : optProperties.progress);\n\tobstacle.properties.sprite = ((optProperties.sprite === null) ? obstacle.properties.sprite : optProperties.sprite);\n\tobstacle.properties.isActive = (obstacle.progress <= 0);\n};\n\nccObstacles.prototype.findObstacleType = function(type){\n\tvar currentNode = this.typesList.head;\n\twhile(currentNode !== null){\n\t\tif(currentNode.obj.type === type){\n\t\t\treturn currentNode.obj;\n\t\t}\n\t\tcurrentNode = currentNode.next;\n\t}\n\treturn undefined;\n};\n\nwindow.ccObstacles = ccObstacles;\nmodule.exports = ccObstacles;\n\n","var ObstacleObj = require('./ObstacleObj.js');\n\nvar ObstacleList = function(typeProperties){\n\tthis.lastActiveNode = null;\n\tthis.currentUpdateNode = null;\n\tthis.properties = typeProperties;\n\tthis.init();\n}\n\nObstacleList.prototype = new window.dLinkedList();\n\nObstacleList.prototype.init = function(){\n\tvar firstNode = this.addObstacleNode();\n\tthis.lastActiveNode = firstNode;\n};\n\nObstacleList.prototype.enterObstacle = function(){\n\tvar nextNode = this.lastActiveNode.next;\n\tif(nextNode===null){\n\n\t}\n\telse{\n\t\tvar nextObstacle = nextNode.obj;\n\t\tvar enterObstacleNode = null;\n\n\t\tif(nextObstacle.active === true){\n\t\t\tenterObstacleNode = this.addObstacleNode();\n\t\t\tthis.lastActiveNode = enterObstacleNode;\n\t\t}\n\t\telse{\n\t\t\tenterObstacleNode = nextObstacle;\n\t\t\tthis.lastActiveNode = enterObstacleNode\n\t\t}\n\t\treturn this.lastActiveNode.obj;\n\t}\n};\n\nObstacleList.prototype.addObstacleNode = function(){\n\tvar obstacle = new ObstacleObj;\n\tfor(var i = 0; i < arguments.length; i++){\n\t\tobstacle.speed = this.properties.speed;\n\t\tobstacle.sprite = this.properties.sprite;\n\t}\n\n\tvar node;\n\t\n\tif(this.lastActiveNode===null){\n\t\tnode = this.push(obstacle)\n\t}\n\telse{\n\t\tnode = this.insertAfter(this.lastActiveNode,obstacle);\n\t}\n\n\tthis.lastActiveNode = node;\n\t\n\treturn node;\n};\n\nObstacleList.prototype.updateNodes = function(dt){\n\tvar startNode = this.lastActiveNode;\n\tvar updateObstacle = function(currentNode){\n\t\tconsole.log(dt);\n\t\tvar obstacle = currentNode.obj;\n\t\tif(obstacle.properties.isActive === true){\n\t\t\tobstacle.update(dt);\n\t\t}\n\t\treturn obstacle.properties.isActive;\n\t}\n\n\tthis.iterate(updateObstacle,false,startNode);\n};\n\nmodule.exports = ObstacleList;","var ObstacleProperties = require('./ObstacleProperties');\n\nvar ObstacleObj = function(){\n\tthis.properties = new ObstacleProperties();\n};\n\nObstacleObj.prototype.update = function(dt){\n\ttry{\n\t\tthis.properties.progress = this.properties.progress + (dt*this.properties.speed);\n\t}\n\tcatch(e){\n\t\tconsole.log(e);\n\t}\n\tif(this.properties.progress >= 1){\n\t\tthis.properties.isActive = false;\n\t\tthis.properties.progress = 0;\n\t}\n};\n\nmodule.exports = ObstacleObj;\n\n","var ObstacleProperties = function(){\n\tthis.speed = 0;\n\tthis.sprite = null;\n\tthis.progress = 0;\n\tthis.isActive = false;\n};\n\nmodule.exports = ObstacleProperties;\n","var ObstacleList = require('./ObstacleList');\nvar ObstacleProperties = require('./ObstacleProperties');\n\nvar ObstacleType = function(){\n\tthis.type = -1;\n\tthis.properties = new ObstacleProperties();\n\tconsole.log(this.properties.speed);\n\tthis.obstacleList = new ObstacleList(this.properties);\n};\n\nObstacleType.prototype.enterObstacle = function(){\n\t//check if the node after the last entered node is active, else add one\n\tvar obstacle = this.obstacleList.enterObstacle();\n\treturn obstacle;\n};\n\nObstacleType.prototype.update = function(dt){\t\n\tthis.obstacleList.updateNodes(dt);\n};\n\nObstacleType.prototype.setProperties = function(properties){\n\tthis.properties.speed = ((properties.speed === null) ? this.properties.speed: properties.speed);\n\tthis.properties.progress = ((properties.progress === null) ? this.properties.progress : properties.progress);\n\tthis.properties.sprite = ((properties.sprite === null) ? this.properties.sprite : properties.sprite);\n\tthis.obstacleList.properties = this.properties;\n};\n\nmodule.exports = ObstacleType;\n"]}
{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/CCObstacles.js","src/ObstacleList.js","src/ObstacleObj.js","src/ObstacleProperties.js","src/ObstacleType.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"CCObstacles.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var ObstacleObj = require('./ObstacleObj');\nvar ObstacleType = require('./ObstacleType');\n\nvar ccObstacles = function(){\n\tthis.typesArr = [];\n};\n\n//properties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.addObstacleType = function(type,properties){\n\t//only do something is type hasn't already been added\n\tif(this.findObstacleType(type)===undefined){\n\t\t\tif(properties==undefined){\n\t\t\t\tproperties = {};\n\t\t\t}\n\t\t\tvar obstacleType = new ObstacleType(properties);\n\t\t\tobstacleType.type = type;\n\n\t\t\tthis.typesArr[this.typesArr.length] = obstacleType;\n\t}\n};\n\n//properties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.changeObstacleTypeProperties = function(type,properties){\n\n\tvar obstacleType = this.findObstacleType(type);\n\tif(properties !=null){\n\t\tproperties = {};\n\t}\n\t//set optional properties\n\t\tthis.setObstacleProperties(obstacleType,properties);\n};\n\n//enterObstacle takes variable arguments (1-2) of 1.type 2.optProperties\n//optProperties is an object containing optional obstacle properties such as speed...\nccObstacles.prototype.enterObstacle = function(){\n\n\tvar type = arguments[0];\n\tvar obstacleType = this.findObstacleType(type);\n\tvar obstacle = obstacleType.enterObstacle();\n\n\tif(arguments[1] != null){\n\t\tthis.setObstacleProperties(obstacle,arguments[1]);\n\t}\n\t\n};\n\nccObstacles.prototype.update = function(dt){\n\tfor(var i = 0; i< this.typesArr.length; i++){\n\t\tthis.typesArr[i].update(dt);\n\t}\n}\t\t\t\t\t\n\nccObstacles.prototype.setObstacleProperties = function(obstacle,optProperties){\n\tobstacle.properties.speed = ((optProperties.speed == null) ? obstacle.properties.speed: optProperties.speed);\n\tobstacle.properties.progress = ((optProperties.progress == null) ? obstacle.properties.progress : optProperties.progress);\n\tobstacle.properties.sprite = ((optProperties.sprite == null) ? obstacle.properties.sprite : optProperties.sprite);\n\tobstacle.properties.isActive = (obstacle.progress <= 0);\n};\n\nccObstacles.prototype.findObstacleType = function(type){\n\tvar currentTypeObj;\n\tfor(var i = 0; i< this.typesArr.length; i++){\n\t\tcurrentTypeObj = this.typesArr[i];\n\t\tif(currentTypeObj.type === type){\n\t\t\treturn currentTypeObj;\n\t\t}\n\t}\n\treturn undefined;\n};\n\nccObstacles.prototype.applyToEveryType = function(callback){\n\tconsole.log(this.typesArr.length);\n\tfor(var i = 0; i< this.typesArr.length; i++){\n\t\tvar otNode = this.typesArr[i];\n\t\tcallback(otNode);\n\t}\n}\n\nwindow.ccObstacles = ccObstacles;\nmodule.exports = ccObstacles;\n\n","var ObstacleObj = require('./ObstacleObj.js');\n\nvar ObstacleList = function(){\n\tthis.lastActiveNode = null;\n\tthis.currentUpdateNode = null;\n\tthis.properties = {};\n}\n\nObstacleList.prototype = new window.dLinkedList();\n\nObstacleList.prototype.init = function(){\n\tvar firstNode = this.addObstacleNode();\n};\n\nObstacleList.prototype.enterObstacle = function(){\n\t\n\tvar nextNode;\n\tif(this.lastActiveNode.obj.properties.isActive === false){\n\t\tthis.lastActiveNode.obj.properties.isActive = true;\n\t\treturn this.lastActiveNode;\n\t}\n\telse{\n\n\t\t\tif((this.lastActiveNode == null)||(this.lastActiveNode === this.tail)){\n\t\t\t\tnextNode = this.head;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnextNode = this.lastActiveNode.next;\n\t\t\t}\n\t\t\t\n\t\t\tvar enterObstacleNode = null;\n\n\t\t\tif(nextNode!==null){\n\t\t\t\tvar nextObstacle = nextNode.obj;\n\t\t\t\tif(nextObstacle.active === true){\n\t\t\t\t\tenterObstacleNode = this.addObstacleNode();\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tenterObstacleNode = nextObstacle;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tenterObstacleNode = this.addObstacleNode();\n\t\t\t}\n\n\t\t\tenterObstacleNode.obj.properties.isActive = true;\n\t\t\tthis.lastActiveNode = enterObstacleNode;\n\n\t\t\treturn enterObstacleNode.obj;\n\n\t}\n\n\t\n};\n\nObstacleList.prototype.addObstacleNode = function(){\n\tvar obstacle = new ObstacleObj;\n\tobstacle.properties.speed = this.properties.speed;\n\tobstacle.properties.sprite = this.properties.sprite;\n\n\tvar node;\n\t\n\tif(this.lastActiveNode===null){\n\t\tnode = this.push(obstacle)\n\t}\n\telse{\n\t\tnode = this.insertAfter(this.lastActiveNode,obstacle);\n\t}\n\n\tthis.lastActiveNode = node;\n\t\n\treturn node;\n};\n\nObstacleList.prototype.updateNodes = function(dt){\n\tvar startNode = this.lastActiveNode;\n\tvar isFirstIteration = false;\n\tvar updateObstacle = function(currentNode){\n\t\t\n\t\tif(isFirstIteration === true){\n\t\t\t//if back at the begining of the list, end\n\t\t\tif(currentNode == startNode){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar obstacle = currentNode.obj;\n\t\tif(obstacle.properties.isActive === true){\n\t\t\tobstacle.update(dt);\n\t\t}\n\t\tisFirstIteration = true;\n\t\treturn obstacle.properties.isActive;\n\t}\n\n\tthis.iterateOnceThrough(updateObstacle,false,startNode,true);\n};\n\nmodule.exports = ObstacleList;","var ObstacleProperties = require('./ObstacleProperties');\n\nvar ObstacleObj = function(){\n\tthis.properties = new ObstacleProperties();\n};\n\nObstacleObj.prototype.update = function(dt){\n \ttry{\n\t\tthis.properties.progress = this.properties.progress + (dt*this.properties.speed);\n\t}\n\tcatch(e){\n\t\tconsole.log(e);\n\t}\n\tif(this.properties.progress >= 1){\n\t\tthis.properties.isActive = false;\n\t\tthis.properties.progress = 0;\n\t}\n};\n\nmodule.exports = ObstacleObj;\n\n","var ObstacleProperties = function(){\n\tthis.speed = 0;\n\tthis.sprite = null;\n\tthis.progress = 0;\n\tthis.isActive = false;\n};\n\nmodule.exports = ObstacleProperties;\n","var ObstacleList = require('./ObstacleList');\nvar ObstacleProperties = require('./ObstacleProperties');\n\nvar ObstacleType = function(properties){\n\tthis.type = -1;\n\tthis.properties = new ObstacleProperties();\n\tthis.obstacleList = new ObstacleList(this.properties);\n\tthis.setProperties(properties);\n\tthis.obstacleList.init();\n};\n\nObstacleType.prototype.enterObstacle = function(){\n\t//check if the node after the last entered node is active, else add one\n\tvar obstacle = this.obstacleList.enterObstacle();\n\treturn obstacle;\n};\n\nObstacleType.prototype.update = function(dt){\t\n\tthis.obstacleList.updateNodes(dt);\n};\n\nObstacleType.prototype.setProperties = function(properties){\n\tthis.properties.speed = ((properties.speed == null) ? this.properties.speed: properties.speed);\n\tthis.properties.progress = ((properties.progress == null) ? this.properties.progress : properties.progress);\n\tthis.properties.sprite = ((properties.sprite == null) ? this.properties.sprite : properties.sprite);\n\tthis.obstacleList.properties = this.properties;\n};\n\nmodule.exports = ObstacleType;\n"]}